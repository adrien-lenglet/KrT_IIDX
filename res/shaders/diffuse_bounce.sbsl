
render_pass render_passes::diffuse_bounce : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set random {
		vec3 normals[256];
	};

	set fb {
		usampler2D it_count;
		uint it_bias;

		sampler2D albedo;
		sampler2D normal;
		sampler2D last_diffuse;

		mat4 cur_cam_to_last;
		sampler2D last_frame_diffuse;

		uint index;
	};

	require modules::rt;
	require modules::env;

	out vec3 diffuse;

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	void main(void)
	{
		uint it = min(texture(fb.it_count, gl_FragCoord.xy).x + fb.it_bias, 1);
		if (it == 0) {
			vec4 cur_view =  vec4(rt_current_view(), 1.0);
			vec4 last_view = fb.cur_cam_to_last * cur_view;
			vec2 trace_pos = rt_project_point(last_view.xyz).xy;
			(out)diffuse = texture(fb.last_frame_diffuse, trace_pos).xyz;
		} else {
			vec3 view = rt_pos_view(gl_FragCoord.xy);
			vec3 view_norm = normalize(view);
			vec3 normal = texture(fb.normal, gl_FragCoord.xy).xyz;
			vec3 albedo = texture(fb.albedo, gl_FragCoord.xy).xyz;

			vec3 nx = vec3(-normal.z, normal.y, normal.x);
			vec3 ny = vec3(normal.y, -normal.z, normal.x);
			vec3 nz = normal;

			vec3 illum = vec3(0.0);
			uint samples = it;
			uint rand = hash(uint(gl_FragCoord.x)) + hash(uint(gl_FragCoord.y));
			for (uint i = 0; i < samples; i++) {
				vec3 rvec = random.normals[hash(i + rand) % 256];
				vec3 tangent_rvec = nx * rvec.x + ny * rvec.y + nz * rvec.z;
				const float unorm = 1.0 / 255.0;
				vec3 ray_illum = vec3(0.0);
				if (fb.index == 0) {
					ray_illum = env_sample(normalize((rt_fb.view_normal_inv * vec4(tangent_rvec, 1.0)).xyz));//vec3(100.0 * unorm, 145.0 * unorm, 223.0 * unorm) * 1.5;
				}
				vec2 trace_pos;
				//if (rt_traceRay(view, tangent_rvec, trace_pos))
				//	ray_illum = texture(fb.last_diffuse, trace_pos).xyz;
				illum += ray_illum;
			}
			illum /= samples;

			vec3 cur = albedo * illum;
			//vec3 last = texture(fb.last_frame, gl_FragCoord.xy).xyz;
			//vec3 dif3 = abs(cur - last);
			//float dif = (dif3.x + dif3.y + dif3.z) / 3.0;
			//(out)diffuse += mix(cur, last, clamp(pow(dif, 0.25), 0.0, 1.0));
			(out)diffuse = cur;
		}
	}
}