
set rt_fb {
	sampler2D normal;

	sampler2D depth_buffer;
	sampler2D depth_buffer_fl;
	vec2 depth_buffer_fl_size;
	int depth_buffer_trace_res;
	uint depth_buffer_max_it;

	float cur_cam_a, cur_cam_b;
	float cur_cam_far, cur_cam_near;
	vec2 cur_cam_ratio;
	mat4 last_cam_proj;
};


float rt_depth_to_z(float depth)
{
	return rt_fb.cur_cam_b / (depth -  rt_fb.cur_cam_a);
}

float rt_z_to_depth(float z)
{
	return rt_fb.cur_cam_b / z + rt_fb.cur_cam_a;
}

vec2 rt_ndc_to_ss(vec2 p)
{
	vec2 size = textureSize(rt_fb.depth_buffer, 0);
	return ((p / 2.0) + 0.5) * size;
}

vec3 rt_pos_view(vec2 pos)
{
	vec2 size = vec2(1.0) / textureSize(rt_fb.depth_buffer, 0);
	float depth = textureLod(rt_fb.depth_buffer, pos, 0).x;
	float z = rt_depth_to_z(depth);
	vec2 uv = pos * size;
	vec2 ndc2 = (uv - 0.5) * 2.0;
	ndc2 *= rt_fb.cur_cam_ratio;
	ndc2 *= z;
	return vec3(ndc2, z);
}

vec3 rt_current_view(void)
{
	return rt_pos_view(gl_FragCoord.xy);
}

vec3 rt_project_point(vec3 point)
{
	vec4 ph = rt_fb.last_cam_proj * vec4(point, 1.0);
	vec3 res = ph.xyz / ph.w;
	return vec3(rt_ndc_to_ss(res.xy), res.z);
}

// origin is start of the ray, camera space
// dir is the direction of the ray, camera space
void rt_project_ray(vec3 origin, vec3 dir, out vec3 ss_p0, out vec3 ss_p1)
{
	if (dir.z == 0.0) {
		ss_p0 = rt_project_point(origin);
		ss_p1 = rt_project_point(origin + dir * 16000.0);	// max screen size is 16k because of that 'trick'
		return;
	}
	float len;
	if (dir.z > 0.0)
		len = (rt_fb.cur_cam_far - origin.z) / dir.z;
	else
		len = (rt_fb.cur_cam_near - origin.z) / dir.z;
	vec3 end = origin + dir * len;
	/*if (origin.z < camera.near || origin.z > camera.far) {
		if (dir.z > 0.0)
			len = (camera.near - origin.z) / dir.z;
		else
			len = (camera.far - origin.z) / dir.z;
		origin += dir * len;
	}*/
	ss_p0 = rt_project_point(origin);
	ss_p1 = rt_project_point(end);
}

const float rt_inf = 1.0 / 0.0;

float rt_inter_rect(vec2 tl, vec2 br, vec2 p, vec2 d)
{
	return min(
		d.x == 0.0 ? rt_inf : (d.x > 0.0 ? (br.x - p.x) / d.x : (tl.x - p.x) / d.x),
		d.y == 0.0 ? rt_inf : (d.y > 0.0 ? (br.y - p.y) / d.y : (tl.y - p.y) / d.y)
	);
}
bool rt_inter_rect_strong(vec2 tl, vec2 br, vec2 p, vec2 d, float bias, out float res)
{
	res = rt_inter_rect(tl, br, p, d);

	vec2 inter = p + (res - bias) * d;
	return inter.x >= tl.x && inter.y >= tl.y && inter.x <= br.x && inter.y <= br.y;
}
// returns t intersection
float rt_cell_end(vec2 p, vec2 d, float size)
{
	vec2 cell_tl = floor(p / size) * size;
	return rt_inter_rect(cell_tl, cell_tl + size, p, d);
}

bool rt_traceRay(vec3 origin, vec3 dir, out vec2 pos)
{
	vec3 p0, p1;
	rt_project_ray(origin, dir, p0, p1);

	vec3 normal = normalize(textureLod(rt_fb.normal, p0.xy, 0)).xyz;

	float bias = 0.025 * (1.0 - max(dot(normalize(origin), -normal), 0.0));

	vec2 dir2 = p1.xy - p0.xy;
	if (dir2 == vec2(0.0))
		return false;
	vec2 dir2n = -dir2;
	float dir_pp_bias = (1.0 / length(dir2)) / 64.0;

	float t = 0.0;

	int level = 0;

	float t_max;
	if (!rt_inter_rect_strong(vec2(0.0), vec2(textureSize(rt_fb.depth_buffer, 0) - 1), p0.xy, dir2, dir_pp_bias, t_max))
		return false;

	vec3 p = p0;
	uint it = 0;

	if (dot(normal, dir) < 0.0) {
		pos = p.xy;
		return true;
	}

	t += rt_cell_end(p.xy, dir2, float(1 << rt_fb.depth_buffer_trace_res)) + dir_pp_bias;
	p = mix(p0, p1, t);

	while (it++ < rt_fb.depth_buffer_max_it) {
		if (t >= t_max)
			return false;
		int cur_lev = level + rt_fb.depth_buffer_trace_res;
		int cell_lev = level == 0 ? 0 : cur_lev;
		float cell_size = float(1 << cell_lev);
		float start_d = mix(p0.z, p1.z, t + rt_cell_end(p.xy, dir2n, cell_size));
		float end_d = mix(p0.z, p1.z, t + rt_cell_end(p.xy, dir2, cell_size));
		vec4 range = textureLod(rt_fb.depth_buffer_fl, p.xy * rt_fb.depth_buffer_fl_size, cell_lev);
		if (level == 0)
			range.x = rt_z_to_depth(rt_depth_to_z(range.x) + bias);
		if ((start_d >= range.x && start_d <= range.y) || (end_d >= range.x && end_d <= range.y) ||
		(start_d >= range.z && start_d <= range.w) || (end_d >= range.z && end_d <= range.w)) {
			if (level == 0) {
				pos = p.xy;
				return true;
			}
			level--;
		} else {
			t += rt_cell_end(p.xy, dir2, float(1 << cur_lev)) + dir_pp_bias;
			p = mix(p0, p1, t);
			level++;
		}
	}
	return false;
}