
render_pass render_passes::post : lighting;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		sampler2D color;
		sampler2D depth_buffer;
	};

	const float pi = 3.141592653589793238462643383279502884;

	float ang_to_rad(float ang)
	{
		return ang * (pi / 180.0);
	}

	vec3 current_view(void)
	{
		vec2 size = textureSize(fb.color, 0);
		vec2 uv = gl_FragCoord.xy / size;
		float depth = texture(fb.depth_buffer, uv).x;
		const float near = 0.1, far = 1000.0;
		const float a = far / (far - near), b = -(far * near) / (far - near);
		const float tanHalfFovy = tan(ang_to_rad(120.0) / 2.0);
		float z = b / (depth - a);
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2.x *= (16.0 / 9.0) * tanHalfFovy;
		ndc2.y *= -1.0 * tanHalfFovy;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	require modules::camera;

	out vec3 wsi_screen;

	const float near_plane = 0.1;
	const float far_plane = 1000.0;

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(fb.color, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = camera.proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	// origin is start of the ray, camera space
	// dir is the direction of the ray, camera space
	void project_ray(vec3 origin, vec3 dir, out vec3 ss_p0, out vec3 ss_p1)
	{
		if (dir.z == 0.0) {
			ss_p0 = project_point(origin);
			ss_p1 = project_point(origin + dir * 16000.0);	// max screen size is 16k because of that 'trick'
			return;
		}
		float len;
		if (dir.z > 0.0) {
			len = (far_plane - origin.z) / dir.z;
		} else {
			len = (near_plane - origin.z) / dir.z;
		}
		vec3 end = origin + dir * len;
		ss_p0 = project_point(origin);
		ss_p1 = project_point(end);
	}

	bool isShadow()
	{
		vec2 size = textureSize(fb.color, 0);
		//vec3 sun_dir = normalize(vec3(-1.0, 0.0, 0.1)).xyz;
		vec3 sun_dir = normalize(vec3(-1.0, 1.0, -1.0)).xyz;
		vec3 origin = current_view();//texture(fb.view, gl_FragCoord.xy / size).xyz;
		vec3 p0, p1;
		project_ray(origin, sun_dir, p0, p1);
		vec2 dir = p1.xy - p0.xy;
		float dir_pp = 1.0 / length(dir);

		float z0 = p0.z;
		float z1 = p1.z;
		//float z0_inv = 1.0 / z0;
		//float z1_inv = 1.0 / z1;
		float t = 0.0;
		vec2 coord = p0.xy;

		t = dir_pp / 16.0;
		coord = mix(p0.xy, p1.xy, t);
		float bdepth = texture(fb.depth_buffer, coord / size).x;
		float bray_depth = mix(z0, z1, t);

		bool base_comp = bdepth > bray_depth;

		t = 0.0;
		coord = p0.xy;

		while (coord.x > 0 && coord.y > 0 && coord.x < size.x && coord.y < size.y && t < 1.0) {
			t += dir_pp;
			coord = mix(p0.xy, p1.xy, t);

			float depth = texture(fb.depth_buffer, coord / size).x;
			float ray_depth = mix(z0, z1, t);
			if ((depth > ray_depth) != base_comp)
				return true;
		}
		return false;
	}

	void main(void)
	{
		/*vec3 p0, p1;
		project_ray(vec3(0.0, 0.0, 10.0), normalize(vec3(0.0, 0.0, 1.0)), p0, p1);
		vec2 point = gl_FragCoord.xy;
		float len = length(point - p1.xy) / 1000.0;

		(out)wsi_screen = vec3(len);

		return;*/

		//(out)wsi_screen = texture(fb.color, vec2(tan(uv.x / 4.0 + 1.0), tan(uv.y / 8.0))).xyz;
		if (isShadow())
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz / 16.0;
		else
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz;
		//(out)wsi_screen = texture(fb.view, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz / 4.0;
		//(out)wsi_screen = subpassLoad((in)color).xyz + vec3(abs(texture(fb.depth_buffer, (gl_FragCoord.xy / textureSize(fb.depth_buffer, 0)) * 16.0).x - 0.5) / 2.0);
	}
}