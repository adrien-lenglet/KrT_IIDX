
render_pass render_passes::lighting : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		usampler2D it_count;
		uint it_bias;

		sampler2D albedo;
		sampler2D emissive;
		sampler2D normal;

		sampler2D last_lighting;
		sampler2D last_albedo;
		sampler2D last_emissive;

		mat4 cur_cam_to_last;
		mat4 view_normal;

		vec3 sun_dir[256];
	};

	require modules::rt;

	out vec3 primary;

	float schlick_fresnel(const float n1, const float n2, float cos_angle)
	{
		const float r0_root = (n1 - n2) / (n1 + n2);
		const float r0 = r0_root * r0_root;
		return r0 + (1.0 - r0) * pow(1 - cos_angle, 5);
	}

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	void main(void)
	{
		uint it = min(texture(fb.it_count, gl_FragCoord.xy).x + fb.it_bias, 1);
		if (it == 0) {
			vec4 cur_view =  vec4(rt_current_view(), 1.0);
			vec4 last_view = fb.cur_cam_to_last * cur_view;
			vec2 trace_pos = rt_project_point(last_view.xyz).xy;
			(out)primary = texture(fb.last_lighting, trace_pos).xyz;
		} else {
			float illum = 0.0;
			for (uint i = 0; i < it; i++) {
				uint rand = hash(uint(gl_FragCoord.x) + i) + hash(uint(gl_FragCoord.y));
				vec3 sun_dir = (fb.view_normal * vec4(fb.sun_dir[rand % 256], 1.0)).xyz;
				vec3 view = rt_pos_view(gl_FragCoord.xy);
				vec3 view_norm = normalize(view);
				vec3 normal = texture(fb.normal, gl_FragCoord.xy).xyz;
				vec2 trace_pos;
				float ill = max(dot(normal, sun_dir), 0.0);
				if (ill > 0.0)
					if (rt_traceRay(view, sun_dir, trace_pos))
						ill = 0.0;
				illum += ill;
			}
			illum /= float(it);
			vec3 emissive = texture(fb.emissive, gl_FragCoord.xy).xyz;
			vec3 albedo = texture(fb.albedo, gl_FragCoord.xy).xyz;
			vec3 base_color = albedo * illum * vec3(2.0, 2.0, 1.0) * 1.9 + emissive;
			(out)primary = base_color;
		}
		/*base_color = vec3(texture(fb.depth_buffer_fl, gl_FragCoord.xy * fb.depth_buffer_fl_size, 9).xy, 0.0);
		base_color.x = depth_to_z(base_color.x) * 0.01;
		base_color.y = depth_to_z(base_color.y) * 0.01;*/

		/*const float unorm = 1.0 / 255.0;
		vec3 refl_color = vec3(2.0 * unorm, 145.0 * unorm, 223.0 * unorm);
		if (traceRay(view, reflect(view_norm, normal), 0, trace_pos)) {
			vec3 normal = normalize((texture(fb.normal, trace_pos).xyz - 0.5) * 2.0);
			float illum = max(dot(normal, sun_dir), 0.0);
			vec3 refl_view = pos_view(trace_pos);
			vec2 trace_pos_shadow;
			if (illum > 0.0) {
				if (traceRay(refl_view, sun_dir, 0, trace_pos_shadow))
					illum = 0.03;
			} else
				illum = 0.03;
			vec4 emissive = texture(fb.emissive, trace_pos);
			vec3 emissive_exp = emissive.xyz * pow(2, emissive.w);
			vec4 albedo = texture(fb.albedo, trace_pos);
			refl_color = albedo.xyz * illum + emissive_exp;
		}*/
		//(out)primary = mix(base_color, refl_color, albedo_factor * schlick_fresnel(1.0, 1.33, max(dot(-view_norm, normal), 0)));
		//(out)primary = textureLod(fb.depth_buffer_fl, gl_FragCoord.xy / vec2(textureSize(fb.depth_buffer_fl, 0)) * 0.5, 0).xyz;
		//(out)wsi_screen = vec3(illum);
	}
}