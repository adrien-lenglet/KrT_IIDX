
render_pass render_passes::lighting : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		usampler2D it_count;
		uint it_bias;

		sampler2D albedo;
		sampler2D emissive;
		sampler2D normal;

		sampler2D last_lighting;
		sampler2D last_albedo;
		sampler2D last_emissive;

		sampler2D depth_buffer;
		sampler2D depth_buffer_fl;
		sampler2D depth_buffer_fl_lin;
		vec2 depth_buffer_fl_size;
		int depth_buffer_trace_res;
		uint depth_buffer_max_it;

		mat4 cur_cam_to_last;
		float cur_cam_a, cur_cam_b;
		vec2 cur_cam_ratio;
		mat4 last_cam_proj;

		vec3 sun_dir[256];
	};

	require modules::camera;

	float repr_depth_to_z(float depth)
	{
		return fb.cur_cam_b / (depth - fb.cur_cam_a);
	}

	vec3 repr_pos_view(vec2 pos)
	{
		vec2 size = textureSize(fb.depth_buffer, 0);
		float depth = textureLod(fb.depth_buffer, pos, 0).x;
		float z = repr_depth_to_z(depth);
		vec2 uv = pos / size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= fb.cur_cam_ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 repr_current_view(void)
	{
		return repr_pos_view(gl_FragCoord.xy);
	}

	vec2 repr_ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(fb.depth_buffer, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 repr_project_point(vec3 point)
	{
		vec4 ph = fb.last_cam_proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(repr_ndc_to_ss(res.xy), res.z);
	}

	float depth_to_z(float depth)
	{
		return camera.b / (depth - camera.a);
	}

	float z_to_depth(float z)
	{
		return camera.b / z + camera.a;
	}

	vec3 pos_view(vec2 pos)
	{
		vec2 size = vec2(1.0) / textureSize(fb.depth_buffer, 0);
		float depth = textureLod(fb.depth_buffer_fl_lin, pos * fb.depth_buffer_fl_size, 0).x;
		float z = depth_to_z(depth);
		vec2 uv = pos * size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= camera.ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 current_view(void)
	{
		return pos_view(gl_FragCoord.xy);
	}

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(fb.depth_buffer, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 pos_view_precise(vec2 pos)
	{
		vec2 size = vec2(1.0) / textureSize(fb.depth_buffer, 0);
		float depth = textureLod(fb.depth_buffer, pos, 0).x;
		float z = depth_to_z(depth);
		vec2 uv = pos * size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= camera.ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = camera.proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	// origin is start of the ray, camera space
	// dir is the direction of the ray, camera space
	void project_ray(vec3 origin, vec3 dir, out vec3 ss_p0, out vec3 ss_p1)
	{
		if (dir.z == 0.0) {
			ss_p0 = project_point(origin);
			ss_p1 = project_point(origin + dir * 16000.0);	// max screen size is 16k because of that 'trick'
			return;
		}
		float len;
		if (dir.z > 0.0)
			len = (camera.far - origin.z) / dir.z;
		else
			len = (camera.near - origin.z) / dir.z;
		vec3 end = origin + dir * len;
		if (origin.z < camera.near || origin.z > camera.far) {
			if (dir.z > 0.0)
				len = (camera.near - origin.z) / dir.z;
			else
				len = (camera.far - origin.z) / dir.z;
			origin += dir * len;
		}
		ss_p0 = project_point(origin);
		ss_p1 = project_point(end);
	}

	const float inf = 1.0 / 0.0;

	float inter_rect(vec2 tl, vec2 br, vec2 p, vec2 d)
	{
		return min(
			d.x == 0.0 ? inf : (d.x > 0.0 ? (br.x - p.x) / d.x : (tl.x - p.x) / d.x),
			d.y == 0.0 ? inf : (d.y > 0.0 ? (br.y - p.y) / d.y : (tl.y - p.y) / d.y)
		);
	}
	bool inter_rect_strong(vec2 tl, vec2 br, vec2 p, vec2 d, float bias, out float res)
	{
		res = inter_rect(tl, br, p, d);

		vec2 inter = p + (res - bias) * d;
		return inter.x >= tl.x && inter.y >= tl.y && inter.x <= br.x && inter.y <= br.y;
	}
	// returns t intersection
	float cell_end(vec2 p, vec2 d, int level)
	{
		float size = float(1 << level);
		vec2 cell_tl = floor(p / size) * size;
		vec2 cell_br = cell_tl + size;

		return inter_rect(cell_tl, cell_br, p, d);
	}

	bool traceRay(vec3 origin, vec3 dir, out vec2 pos)
	{
		vec3 p0, p1;
		project_ray(origin, dir, p0, p1);

		vec3 normal = normalize(textureLod(fb.normal, p0.xy, 0)).xyz;

		float bias = 0.025 * (1.0 - max(dot(normalize(origin), -normal), 0.0));

		vec2 dir2 = p1.xy - p0.xy;
		if (dir2 == vec2(0.0))
			return false;
		vec2 dir2n = -dir2;
		float dir_pp_bias = (1.0 / length(dir2)) / 64.0;

		float t = 0.0;

		int level = 0;

		float t_max;
		if (!inter_rect_strong(vec2(0.0), vec2(textureSize(fb.depth_buffer, 0) - 1), p0.xy, dir2, dir_pp_bias, t_max))
			return false;

		vec3 p = p0;
		uint it = 0;

		if (dot(normal, dir) < 0.0) {
			pos = p.xy;
			return true;
		}

		t += cell_end(p.xy, dir2, fb.depth_buffer_trace_res) + dir_pp_bias;
		if (t >= t_max)
			return false;
		p = mix(p0, p1, t);

		while (it++ < fb.depth_buffer_max_it) {
			int cur_lev = level + fb.depth_buffer_trace_res;
			int cell_lev = level == 0 ? 0 : cur_lev;
			float t_start = t + cell_end(p.xy, dir2n, cell_lev);
			float t_end = t + cell_end(p.xy, dir2, cell_lev);
			float start_d = mix(p0.z, p1.z, t_start);
			float end_d = mix(p0.z, p1.z, t_end);
			vec2 range = textureLod(fb.depth_buffer_fl, p.xy * fb.depth_buffer_fl_size, cur_lev).xy;
			bool cond = (start_d >= range.x && start_d <= range.y) || (end_d >= range.x && end_d <= range.y) || (start_d <= range.y && end_d >= range.x) || (start_d >= range.y && end_d <= range.x);;
			if (level == 0) {
				float r_depth = textureLod(fb.depth_buffer, p.xy, 0).x;
				range = vec2(z_to_depth(depth_to_z(r_depth) + bias), textureLod(fb.depth_buffer_fl, p.xy * fb.depth_buffer_fl_size, 0).y);
				float depth = mix(p0.z, p1.z, mix(t_start, t_end, .5));
				cond = depth >= range.x && depth <= range.y;
			}
			if (cond) {
				if (level == 0) {
					pos = p.xy;
					return true;
				}
				level--;
			} else {
				t += cell_end(p.xy, dir2, cur_lev) + dir_pp_bias;
				if (t >= t_max)
					return false;
				p = mix(p0, p1, t);
				level++;
			}
		}
		return false;
	}

	out vec3 primary;

	float schlick_fresnel(const float n1, const float n2, float cos_angle)
	{
		const float r0_root = (n1 - n2) / (n1 + n2);
		const float r0 = r0_root * r0_root;
		return r0 + (1.0 - r0) * pow(1 - cos_angle, 5);
	}

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	void main(void)
	{
		uint it = min(texture(fb.it_count, gl_FragCoord.xy).x + fb.it_bias, 1);
		if (it == 0) {
			vec4 cur_view =  vec4(repr_current_view(), 1.0);
			vec4 last_view = fb.cur_cam_to_last * cur_view;
			vec2 trace_pos = repr_project_point(last_view.xyz).xy;
			(out)primary = texture(fb.last_lighting, trace_pos).xyz;
		} else {
			float illum = 0.0;
			for (uint i = 0; i < it; i++) {
				uint rand = hash(uint(gl_FragCoord.x) + i) + hash(uint(gl_FragCoord.y));
				vec3 sun_dir = (camera.view_normal * vec4(fb.sun_dir[rand % 256], 1.0)).xyz;
				vec3 view = pos_view_precise(gl_FragCoord.xy);
				vec3 view_norm = normalize(view);
				vec3 normal = texture(fb.normal, gl_FragCoord.xy).xyz;
				vec2 trace_pos;
				float ill = max(dot(normal, sun_dir), 0.0);
				if (ill > 0.0)
					if (traceRay(view, sun_dir, trace_pos))
						ill = 0.0;
				illum += ill;
			}
			illum /= float(it);
			vec3 emissive = texture(fb.emissive, gl_FragCoord.xy).xyz;
			vec3 albedo = texture(fb.albedo, gl_FragCoord.xy).xyz;
			vec3 base_color = albedo * illum * vec3(2.0, 2.0, 1.0) * 1.9 + emissive;
			(out)primary = base_color;
		}
		/*base_color = vec3(texture(fb.depth_buffer_fl, gl_FragCoord.xy * fb.depth_buffer_fl_size, 9).xy, 0.0);
		base_color.x = depth_to_z(base_color.x) * 0.01;
		base_color.y = depth_to_z(base_color.y) * 0.01;*/

		/*const float unorm = 1.0 / 255.0;
		vec3 refl_color = vec3(2.0 * unorm, 145.0 * unorm, 223.0 * unorm);
		if (traceRay(view, reflect(view_norm, normal), 0, trace_pos)) {
			vec3 normal = normalize((texture(fb.normal, trace_pos).xyz - 0.5) * 2.0);
			float illum = max(dot(normal, sun_dir), 0.0);
			vec3 refl_view = pos_view(trace_pos);
			vec2 trace_pos_shadow;
			if (illum > 0.0) {
				if (traceRay(refl_view, sun_dir, 0, trace_pos_shadow))
					illum = 0.03;
			} else
				illum = 0.03;
			vec4 emissive = texture(fb.emissive, trace_pos);
			vec3 emissive_exp = emissive.xyz * pow(2, emissive.w);
			vec4 albedo = texture(fb.albedo, trace_pos);
			refl_color = albedo.xyz * illum + emissive_exp;
		}*/
		//(out)primary = mix(base_color, refl_color, albedo_factor * schlick_fresnel(1.0, 1.33, max(dot(-view_norm, normal), 0)));
		//(out)primary = textureLod(fb.depth_buffer_fl, gl_FragCoord.xy / vec2(textureSize(fb.depth_buffer_fl, 0)) * 0.5, 0).xyz;
		//(out)wsi_screen = vec3(illum);
	}
}