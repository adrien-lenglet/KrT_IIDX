
render_pass render_passes::post : lighting;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		sampler2D color;
		sampler2D depth_buffer;
		sampler2D depth_range;
	};

	const float pi = 3.141592653589793238462643383279502884;

	float ang_to_rad(float ang)
	{
		return ang * (pi / 180.0);
	}

	vec3 current_view(void)
	{
		vec2 size = textureSize(fb.color, 0);
		float depth = texture(fb.depth_buffer, gl_FragCoord.xy).x;
		const float near = 0.1, far = 1000.0;
		const float a = far / (far - near), b = -(far * near) / (far - near);
		const float tanHalfFovy = tan(ang_to_rad(120.0) / 2.0);
		vec2 uv = gl_FragCoord.xy / size;
		float z = b / (depth - a);
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2.x *= (16.0 / 9.0) * tanHalfFovy;
		ndc2.y *= -1.0 * tanHalfFovy;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	require modules::camera;

	out vec3 wsi_screen;

	const float near_plane = 0.1;
	const float far_plane = 1000.0;

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(fb.color, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = camera.proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	// origin is start of the ray, camera space
	// dir is the direction of the ray, camera space
	void project_ray(vec3 origin, vec3 dir, out vec3 ss_p0, out vec3 ss_p1)
	{
		if (dir.z == 0.0) {
			ss_p0 = project_point(origin);
			ss_p1 = project_point(origin + dir * 16000.0);	// max screen size is 16k because of that 'trick'
			return;
		}
		float len;
		if (dir.z > 0.0) {
			len = (far_plane - origin.z) / dir.z;
		} else {
			len = (near_plane - origin.z) / dir.z;
		}
		vec3 end = origin + dir * len;
		ss_p0 = project_point(origin);
		ss_p1 = project_point(end);
	}

	// returns t intersection
	float cell_end(vec2 p, vec2 d, int level)
	{
		int size = 1 << level;
		vec2 cell_tl = vec2(ivec2(p) / size) * vec2(size);
		vec2 cell_br = cell_tl + vec2(size);

		const float inf = 1.0 / 0.0;
		return min(
			d.x == 0.0 ? inf : (d.x > 0.0 ? (cell_br.x - p.x) / d.x : (cell_tl.x - p.x) / d.x),
			d.y == 0.0 ? inf : (d.y > 0.0 ? (cell_br.y - p.y) / d.y : (cell_tl.y - p.y) / d.y)
		);
	}

	bool is_in_range(vec2 range, float value)
	{
		return value >= range.x && value <= range.y;
	}

	bool isLevelSkippable(vec3 p0, vec3 p1, float t, int level, out float t_end)
	{
		vec3 p = mix(p0, p1, t);
		t_end = t + cell_end(p.xy, (p1 - p0).xy, level);
		vec3 p_end = mix(p0, p1, t_end);

		int size = 1 << level;
		ivec2 p_level = ivec2(ivec2(p.xy) / size);
		vec2 range = texelFetch(fb.depth_range, p_level, level - 1).xy;
		return !(is_in_range(range, p.z) || is_in_range(range, p_end.z) || (p.z < range.x && p_end.z > range.y) || (p_end.z < range.x && p.z > range.y));
	}

	bool isShadow()
	{
		vec2 size = textureSize(fb.color, 0);
		vec3 sun_dir = normalize(vec3(0.0, 0.0, -1.0)).xyz;
		vec3 origin = current_view();
		vec3 p0, p1;
		project_ray(origin, sun_dir, p0, p1);
		vec2 dir = p1.xy - p0.xy;
		float dir_pp = 1.0 / length(dir);
		float dir_pp_bias = dir_pp / 64.0;

		float z0 = p0.z;
		float z1 = p1.z;
		float t = dir_pp_bias;
		vec2 coord = p0.xy;

		bool base_comp = false;

		int level = 0;

		if (dir == vec2(0.0))
			return false;

		while (true) {
			/*float t_end;
			bool suc = false;
			while (isLevelSkippable(p0, p1, t, level + 1, t_end)) {
				level++;
				t = t_end + dir_pp_bias;
				suc = true;
			}
			if (!suc) {
				while (level > 0) {
					bool isSkip = isLevelSkippable(p0, p1, t, level, t_end);
					if (isSkip) {
						t = t_end + dir_pp_bias;
						break;
					}
					level--;
				}
			}*/
			coord = mix(p0.xy, p1.xy, t);
			if (!(coord.x >= 0 && coord.y >= 0 && coord.x <= (size.x - 1) && coord.y <= (size.y - 1) && t < 1.0))
				break;
			if (level == 0) {
				float old_t = t;
				float old_ray_depth = mix(z0, z1, t);
				t = t + cell_end(coord, dir, level) + dir_pp_bias;
				float depth = texture(fb.depth_buffer, coord).x;
				float ray_depth = mix(z0, z1, t);
				if ((ray_depth > depth) != base_comp)
					return true;
			}
		}
		return false;
	}

	void main(void)
	{
		if (isShadow())
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz / 16.0;
		else
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz;
	}
}