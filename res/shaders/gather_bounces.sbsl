
render_pass render_passes::gather_bounces : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set light {
		sampler2D primary;
		uint bounce_count;
		sampler2D bounces[16];
		sampler2D last_diffuse;
	};

	out vec3 diffuse;

	void main(void)
	{
		vec3 cur = vec3(0.0);

		cur += texture(light.primary, gl_FragCoord.xy).xyz;
		for (uint i = 0; i < light.bounce_count; i++)
			cur += texture(light.bounces[i], gl_FragCoord.xy).xyz;

		vec3 last = texture(light.last_diffuse, gl_FragCoord.xy).xyz;
		//float last_sum = abs(last.x) + abs(last.y) + abs(last.z);
		vec3 dif3 = abs(cur - last);
		float dif = min((dif3.x + dif3.y + dif3.z) / 3.0, 1.0);
		(out)diffuse = mix(last, cur, clamp(pow(dif, .5), 0.0, 1.0));
		//(out)diffuse = cur;
	}
}