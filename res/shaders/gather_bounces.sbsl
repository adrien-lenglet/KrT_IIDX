
render_pass render_passes::gather_bounces : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set light {
		sampler2D primary;
		uint bounce_count;
		sampler2D bounces[16];
		sampler2D last_diffuse;

		sampler2D depth_buffer;
		mat4 cur_cam_to_last;

		vec3 cur_cam_delta;
		float cur_cam_a, cur_cam_b;
		vec2 cur_cam_ratio;
		mat4 last_cam_proj;
	};

	float depth_to_z(float depth)
	{
		return light.cur_cam_b / (depth - light.cur_cam_a);
	}

	vec3 pos_view(vec2 pos)
	{
		vec2 size = textureSize(light.depth_buffer, 0);
		float depth = textureLod(light.depth_buffer, pos, 0).x;
		float z = depth_to_z(depth);
		vec2 uv = pos / size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= light.cur_cam_ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 current_view(void)
	{
		return pos_view(gl_FragCoord.xy);
	}

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(light.depth_buffer, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = light.last_cam_proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	out vec3 diffuse;

	void main(void)
	{
		vec3 cur = vec3(0.0);

		cur += texture(light.primary, gl_FragCoord.xy).xyz;
		for (uint i = 0; i < light.bounce_count; i++)
			cur += texture(light.bounces[i], gl_FragCoord.xy).xyz;

		vec3 last_view = (light.cur_cam_to_last * vec4(current_view(), 1.0)).xyz;
		vec2 size_d = vec2(textureSize(light.depth_buffer, 0));
		vec2 trace_pos = project_point(last_view).xy;
		if (trace_pos.x >= 0 && trace_pos.y >= 0 && trace_pos.x <= (size_d.x - 1) && trace_pos.y <= (size_d.y - 1)) {
			vec3 last = texture(light.last_diffuse, trace_pos).xyz;
			vec3 dif3 = abs(cur - last);
			float dif = min((dif3.x + dif3.y + dif3.z) / 3.0, 1.0);
			(out)diffuse = mix(last, cur, clamp(0.07 + length(light.cur_cam_delta) * 10.0, 0.0, 1.0));
		} else
			(out)diffuse = cur;

		/*vec3 last = texture(light.last_diffuse, gl_FragCoord.xy).xyz;
		//float last_sum = abs(last.x) + abs(last.y) + abs(last.z);

		vec3 dif3 = abs(cur - last);
		float dif = min((dif3.x + dif3.y + dif3.z) / 3.0, 1.0);
		(out)diffuse = mix(last, cur, clamp(pow(dif, .5), 0.0, 1.0));*/
		//(out)diffuse = cur;
	}
}