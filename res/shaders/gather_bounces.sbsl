
render_pass render_passes::gather_bounces : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set light {
		sampler2D primary;
		uint bounce_count;
		sampler2D bounces[16];

		sampler2D albedo;
		sampler2D emissive;

		sampler2D last_diffuse;
		sampler2D last_albedo;
		sampler2D last_emissive;
		sampler2D last_diffuse_accum;

		sampler2D last_depth_buffer;
		sampler2D depth_buffer;
		mat4 cur_cam_to_last;
		mat4 cur_cam_inv;
		mat4 last_cam_inv;

		vec3 cur_cam_delta;
		float cur_cam_a, cur_cam_b;
		vec2 cur_cam_ratio;
		mat4 last_cam_proj;
	};

	float depth_to_z(float depth)
	{
		return light.cur_cam_b / (depth - light.cur_cam_a);
	}

	vec3 pos_view(vec2 pos)
	{
		vec2 size = textureSize(light.depth_buffer, 0);
		float depth = textureLod(light.depth_buffer, pos, 0).x;
		float z = depth_to_z(depth);
		vec2 uv = pos / size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= light.cur_cam_ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 last_pos_view(vec2 pos)
	{
		vec2 size = textureSize(light.last_depth_buffer, 0);
		float depth = textureLod(light.last_depth_buffer, pos, 0).x;
		float z = depth_to_z(depth);
		vec2 uv = pos / size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= light.cur_cam_ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	vec3 current_view(void)
	{
		return pos_view(gl_FragCoord.xy);
	}

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(light.depth_buffer, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = light.last_cam_proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	out vec3 diffuse;
	out float diffuse_accum;

	void main(void)
	{
		vec3 cur = vec3(0.0);

		cur += texture(light.primary, gl_FragCoord.xy).xyz;
		for (uint i = 0; i < light.bounce_count; i++)
			cur += texture(light.bounces[i], gl_FragCoord.xy).xyz;
		//(out)diffuse = cur;
		//return;

		vec4 cur_view =  vec4(current_view(), 1.0);
		vec4 last_view = light.cur_cam_to_last * cur_view;
		vec2 trace_pos = project_point(last_view.xyz).xy;
		vec4 last_view_reproj = vec4(last_pos_view(trace_pos), 1.0);
		float dist = length((light.cur_cam_inv * cur_view).xyz - (light.last_cam_inv * last_view_reproj).xyz);
		vec2 size_d = vec2(textureSize(light.depth_buffer, 0));
		const float dist_tres = 0.1;
		if (trace_pos.x >= 0 && trace_pos.y >= 0 && trace_pos.x <= (size_d.x - 1) && trace_pos.y <= (size_d.y - 1) && (dist < dist_tres)) {
			const float albedo_bias = 0.001;

			vec3 last_diffuse = texture(light.last_diffuse, trace_pos).xyz;
			vec3 last_albedo = texture(light.last_albedo, trace_pos).xyz + albedo_bias;
			vec3 last_emissive = texture(light.last_emissive, trace_pos).xyz;
			vec3 last_irradiance = (last_diffuse - last_emissive) / last_albedo;

			vec3 albedo = texture(light.albedo, gl_FragCoord.xy).xyz + albedo_bias;
			vec3 emissive = texture(light.emissive, gl_FragCoord.xy).xyz;
			vec3 last = (last_irradiance * albedo) + emissive;

			float last_accum = texture(light.last_diffuse_accum, trace_pos).x;
			float acc = last_accum + 1.0;
			(out)diffuse = (last * last_accum + cur) / acc;
			const float dist_tres_rat = 1.0 / dist_tres;
			(out)diffuse_accum = max(acc * (pow(1.0 - dist * dist_tres_rat, 6.0)), 1.0);
		} else {
				(out)diffuse = cur;
				(out)diffuse_accum = 1.0;
		}
		/*vec3 last = texture(light.last_diffuse, gl_FragCoord.xy).xyz;
		//float last_sum = abs(last.x) + abs(last.y) + abs(last.z);

		vec3 dif3 = abs(cur - last);
		float dif = min((dif3.x + dif3.y + dif3.z) / 3.0, 1.0);
		(out)diffuse = mix(last, cur, clamp(pow(dif, .5), 0.0, 1.0));*/
		//(out)diffuse = cur;
	}
}